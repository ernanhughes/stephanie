{% extends "base.html" %}
{% block content %}
<div class="container-fluid py-3">
  <div class="d-flex align-items-center justify-content-between mb-3">
    <h3 class="mb-0">Nexus Timeline</h3>
    <div class="d-flex gap-2">
      <a class="btn btn-sm btn-outline-secondary" href="/nexus">← Runs</a>
    </div>
  </div>

  <div class="card shadow-sm mb-3">
    <div class="card-body">
      <div class="d-flex flex-wrap align-items-end gap-2">
        <div>
          <label class="form-label mb-0">Baseline</label>
          <input id="inBaseline" class="form-control form-control-sm" style="width:140px" value="{{ baseline }}">
        </div>
        <div>
          <label class="form-label mb-0">Targeted</label>
          <input id="inTargeted" class="form-control form-control-sm" style="width:140px" value="{{ targeted }}">
        </div>
        <button id="btnLoadPair" class="btn btn-sm btn-primary">Load pair</button>

        <div class="ms-auto d-flex align-items-center gap-2">
          <button id="btnPlay" class="btn btn-sm btn-outline-primary">▶ Play</button>
          <input id="rngStep" type="range" min="0" max="0" value="0" step="1" style="width: 320px;">
          <span class="small text-muted"><span id="lblStep">0</span>/<span id="lblTotal">0</span></span>
        </div>
      </div>
    </div>
  </div>

  <!-- TOP: Baseline -->
  <div class="card shadow-sm mb-3">
    <div class="card-header py-2 d-flex justify-content-between align-items-center">
      <strong>Baseline</strong>
      <div class="small text-muted">edges:
        <label class="ms-2"><input type="checkbox" id="chkKnn" checked> knn_* / MST</label>
        <label class="ms-2"><input type="checkbox" id="chkTemporal" checked> temporal_next</label>
        <label class="ms-2"><input type="checkbox" id="chkDiff" checked> highlight new</label>
      </div>
    </div>
    <div class="card-body" style="height:34vh">
      <div id="cyTop" style="width:100%; height:100%; border:1px solid #e5e7eb; border-radius:8px;"></div>
    </div>
  </div>

  <!-- BOTTOM: Targeted -->
  <div class="card shadow-sm">
    <div class="card-header py-2"><strong>Targeted</strong></div>
    <div class="card-body" style="height:34vh">
      <div id="cyBottom" style="width:100%; height:100%; border:1px solid #e5e7eb; border-radius:8px;"></div>
    </div>
  </div>

  <div class="mt-2 small text-muted">
    Scrub or play to watch thoughts accumulate. New nodes/edges each step are highlighted.
  </div>
</div>

<script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const $inBase  = document.getElementById('inBaseline');
  const $inTgt   = document.getElementById('inTargeted');
  const $btnLoad = document.getElementById('btnLoadPair');
  const $btnPlay = document.getElementById('btnPlay');
  const $rng     = document.getElementById('rngStep');
  const $lblS    = document.getElementById('lblStep');
  const $lblT    = document.getElementById('lblTotal');
  const $chkKnn  = document.getElementById('chkKnn');
  const $chkTmp  = document.getElementById('chkTemporal');
  const $chkDiff = document.getElementById('chkDiff');

  let cyTop, cyBottom, framesTop = [], framesBottom = [], cur = 0, playing = false, timer = null;

  async function get(url){ const r = await fetch(url); if(!r.ok) throw new Error(url); return r.json(); }

  function makeCy(id){
    return cytoscape({
      container: document.getElementById(id),
      layout: { name: 'preset', fit: false, padding: 0 },
      pixelRatio: window.devicePixelRatio || 1,
      textureOnViewport: false,
      style: [
        { selector: 'node',
          style: {
            'background-color': '#5b8def',
            'width':'mapData(deg, 0, 16, 10, 32)',
            'height':'mapData(deg, 0, 16, 10, 32)',
            'label':'data(label)','font-size':9,'text-wrap':'wrap','text-max-width':140,'color':'#111'
          }
        },
        { selector: 'edge', style: { 'line-color':'#aab','width':1,'opacity':0.8 } },
        { selector: 'edge[type="temporal_next"]',
          style: { 'line-color':'#e83e8c','width':2,'opacity':0.95,'target-arrow-shape':'triangle','target-arrow-color':'#e83e8c','curve-style':'bezier' }
        },
        { selector: '.newNode', style: { 'background-color':'#22c55e','border-color':'#065f46','border-width':2 } },
        { selector: '.newEdge', style: { 'line-color':'#22c55e','width':2,'opacity':1 } },
        { selector: '.faded',  style: { 'opacity':0.35 } }
      ]
    });
  }

  function rescale(nodes, container, pad=30){
    const withPos = nodes.filter(n => n.position && Number.isFinite(n.position.x) && Number.isFinite(n.position.y));
    if (!withPos.length) return nodes;
    const rect = container.getBoundingClientRect();
    const W = Math.max(10, rect.width-2*pad), H = Math.max(10, rect.height-2*pad);
    let minX=1e9,maxX=-1e9,minY=1e9,maxY=-1e9;
    withPos.forEach(n=>{const p=n.position; if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y;});
    const sx=Math.max(1e-6,maxX-minX), sy=Math.max(1e-6,maxY-minY), k=0.9*Math.min(W/sx,H/sy), cx=(minX+maxX)/2, cy=(minY+maxY)/2;
    return nodes.map(n => n.position ? ({...n, position:{x:(n.position.x-cx)*k+(W/2+pad), y:(n.position.y-cy)*k+(H/2+pad)}}) : n);
  }

  function filterEdges(edges){
    const showK = $chkKnn.checked, showT = $chkTmp.checked;
    return edges.filter(e => {
      const t = (e.data?.type || '').toLowerCase();
      const isKnn = t.startsWith('knn_') || t === 'backbone_mst';
      return (showK && isKnn) || (showT && t === 'temporal_next');
    });
  }

  function degree(edges){
    const d=new Map(); edges.forEach(e=>{d.set(e.data.source,(d.get(e.data.source)||0)+1); d.set(e.data.target,(d.get(e.data.target)||0)+1);}); return d;
  }

  function applyFrame(cy, frames, i){
    const f = frames[Math.max(0, Math.min(i, frames.length-1))];
    const p = frames[Math.max(0, Math.min(i-1, frames.length-1))];
    const nodes = rescale(f.nodes.slice(), cy.container());
    const edges = filterEdges(f.edges.slice());
    const d = degree(edges);
    nodes.forEach(n => n.data.deg = d.get(n.data.id)||0);

    const prevN = new Set((p.nodes||[]).map(n=>n.data.id));
    const prevE = new Set(filterEdges(p.edges||[]).map(e=>e.data.id));
    const diff  = $chkDiff.checked && i>0;

    cy.startBatch();
    cy.elements().remove();
    cy.add(nodes.map(n => ({group:'nodes', data:n.data, position:n.position, classes: diff && !prevN.has(n.data.id) ? 'newNode' : ''})));
    cy.add(edges.map(e => ({group:'edges', data:e.data, classes: diff && !prevE.has(e.data.id) ? 'newEdge' : ''})));
    if (diff){ cy.elements().addClass('faded'); cy.elements('.newNode, .newEdge').removeClass('faded'); }
    else { cy.elements().removeClass('faded newNode newEdge'); }
    cy.endBatch();
  }

  function applyBoth(i){ if(framesTop.length) applyFrame(cyTop, framesTop, i); if(framesBottom.length) applyFrame(cyBottom, framesBottom, i); $lblS.textContent=String(i+1); $rng.value=String(i); }

  async function loadFrames(runId){
    const f = await get(`/nexus/run/${encodeURIComponent(runId)}/frames.json`);
    if (Array.isArray(f)) return f;
    // fallback synth if server returned single graph
    const nodes = f.nodes || [], edges = f.edges || [];
    const step = Math.max(1, Math.ceil((edges.length||1)/30));
    const frames=[]; for(let i=step;i<=edges.length;i+=step){ frames.push({nodes, edges: edges.slice(0,i)}); }
    if (!frames.length) frames.push({nodes, edges});
    return frames;
  }

  async function loadPair(){
    const base = $inBase.value.trim(); const tgt = $inTgt.value.trim();
    if (!cyTop) cyTop = makeCy('cyTop'); if (!cyBottom) cyBottom = makeCy('cyBottom');
    framesTop = base ? await loadFrames(base) : [];
    framesBottom = tgt ? await loadFrames(tgt) : framesTop;
    const L = Math.max(framesTop.length, framesBottom.length);
    $rng.max = String(Math.max(0, L-1)); $lblT.textContent = String(L); cur=0; applyBoth(cur);
  }

  function togglePlay(){
    if (playing){ playing=false; $btnPlay.textContent='▶ Play'; clearInterval(timer); return; }
    playing=true; $btnPlay.textContent='⏸ Pause';
    timer=setInterval(()=>{ const L=Math.max(framesTop.length, framesBottom.length)||1; cur=(cur+1)%L; applyBoth(cur); }, 600);
  }

  $btnLoad.addEventListener('click', loadPair);
  $btnPlay.addEventListener('click', togglePlay);
  $rng.addEventListener('input', ()=>applyBoth(Number($rng.value)));
  [$chkKnn,$chkTmp,$chkDiff].forEach(el=>el.addEventListener('change', ()=>applyBoth(cur)));

  loadPair();
});
</script>
{% endblock %}
