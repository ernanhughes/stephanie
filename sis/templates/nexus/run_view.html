{% extends "base.html" %}
{% block content %}
<div class="container-fluid py-3">
  <div class="d-flex align-items-center justify-content-between mb-3">
    <h3 class="mb-0">Nexus Run: <code id="runId">{{ run_id }}</code></h3>
    <div class="d-flex gap-2">
      <a class="btn btn-sm btn-outline-secondary" href="/nexus">← All runs</a>
      <a class="btn btn-sm btn-outline-primary" id="btnReload">Reload</a>
    </div>
  </div>

  <div class="row g-3">
    <div class="col-lg-8">
      <div class="card shadow-sm">
        <div class="card-body" style="height: 70vh;">
          <div id="cy" style="width:100%; height:100%; border:1px solid #e5e7eb; border-radius:8px;"></div>
        </div>
      </div>
      <div class="mt-2 small text-muted">
        Tip: click a node to see details; use the filter to toggle edge types.
      </div>
    </div>

    <div class="col-lg-4">
      <div class="card shadow-sm mb-3">
        <div class="card-body">
          <h5 class="card-title">Manifest</h5>
          <pre id="manifestPre" class="small" style="white-space:pre-wrap; max-height:30vh; overflow:auto;">Loading…</pre>
          <div class="mt-2 d-flex gap-2">
            <label class="form-label me-2 mb-0">Show edges:</label>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="checkbox" id="chkKnn" checked>
              <label class="form-check-label" for="chkKnn">knn_global</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="checkbox" id="chkTemporal" checked>
              <label class="form-check-label" for="chkTemporal">temporal_next</label>
            </div>
          </div>
        </div>
      </div>

      <div class="card shadow-sm">
        <div class="card-body">
          <h5 class="card-title">Selected</h5>
          <pre id="selectedPre" class="small" style="white-space:pre-wrap; max-height:30vh; overflow:auto;">—</pre>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Cytoscape.js (CDN). If you prefer local, drop a copy into /static and change the src -->
<script src="https://unpkg.com/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const RUN_ID       = {{ run_id | tojson }};
  const $manifest    = document.getElementById('manifestPre');
  const $selected    = document.getElementById('selectedPre');
  const $btnReload   = document.getElementById('btnReload');
  const $chkKnn      = document.getElementById('chkKnn');
  const $chkTemporal = document.getElementById('chkTemporal');
  const $cy          = document.getElementById('cy');

  if (!$manifest || !$selected || !$cy) return;

  let cy;
  let rawGraph = { nodes: [], edges: [] };

  async function fetchJSON(url) {
    const r = await fetch(url);
    if (!r.ok) throw new Error(`GET ${url} -> ${r.status}`);
    return r.json();
  }

  // -- Normalize incoming graph to Cytoscape shape
  function normalizeGraph(g) {
    const nodes = (g.nodes || []).map(n => {
      const d = n.data || n;
      const hasPos = Number.isFinite(d.x) && Number.isFinite(d.y);
      return {
        data: {
          id: String(d.id),
          label: d.label ?? String(d.id),
          type: d.type || 'node',
          weight: d.weight ?? 0,
          // deg set later from filtered edges
        },
        position: hasPos ? { x: d.x, y: d.y } : undefined,
      };
    });

    const edges = (g.edges || []).map(e => {
      const d = e.data || e;
      const source = d.source ?? d.src;
      const target = d.target ?? d.dst;
      return {
        data: {
          id: d.id || `${source}->${target}`,
          source,
          target,
          type: d.type || 'edge',
          weight: d.weight ?? 0
        }
      };
    });

    return { nodes, edges };
  }

  // -- Rescale preset positions (e.g., -1..1) to canvas pixels so zoom ~ 1
  function rescalePreset(nodes, padding = 30) {
    const withPos = nodes.filter(n => n.position && Number.isFinite(n.position.x) && Number.isFinite(n.position.y));
    if (withPos.length !== nodes.length) return nodes; // not a full preset; bail

    const rect = $cy.getBoundingClientRect();
    const W = Math.max(10, rect.width  - 2 * padding);
    const H = Math.max(10, rect.height - 2 * padding);

    let minX = +Infinity, maxX = -Infinity, minY = +Infinity, maxY = -Infinity;
    withPos.forEach(n => {
      const {x, y} = n.position;
      if (x < minX) minX = x; if (x > maxX) maxX = x;
      if (y < minY) minY = y; if (y > maxY) maxY = y;
    });
    const spanX = Math.max(1e-6, maxX - minX);
    const spanY = Math.max(1e-6, maxY - minY);
    const scale = 0.9 * Math.min(W / spanX, H / spanY);
    const cx = (minX + maxX) / 2;
    const cyy = (minY + maxY) / 2;

    return nodes.map(n => {
      const p = n.position;
      return {
        ...n,
        position: {
          x: (p.x - cx) * scale + (W / 2 + padding),
          y: (p.y - cyy) * scale + (H / 2 + padding),
        }
      };
    });
  }

  // -- Edge filtering (group knn_* & backbone_mst under "KNN")
  function filteredElements() {
    const { nodes, edges } = normalizeGraph(rawGraph);

    const showKnn      = $chkKnn?.checked !== false;
    const showTemporal = $chkTemporal?.checked !== false;

    const filteredEdges = edges.filter(e => {
      const t = (e.data.type || '').toLowerCase();
      const isKnn = t.startsWith('knn_') || t === 'backbone_mst';
      if (showKnn && isKnn) return true;
      if (showTemporal && t === 'temporal_next') return true;
      return false;
    });

    // degree from visible edges
    const deg = new Map();
    filteredEdges.forEach(e => {
      deg.set(e.data.source, (deg.get(e.data.source) || 0) + 1);
      deg.set(e.data.target, (deg.get(e.data.target) || 0) + 1);
    });
    nodes.forEach(n => n.data.deg = deg.get(n.data.id) || 0);

    // If we have preset positions, rescale them to canvas pixels
    const allHavePos = nodes.every(n => n.position && Number.isFinite(n.position.x) && Number.isFinite(n.position.y));
    const nodesRescaled = allHavePos ? rescalePreset(nodes) : nodes;

    return { nodes: nodesRescaled, edges: filteredEdges, usePreset: allHavePos };
  }

  function initCy() {
    if (cy) { cy.destroy(); cy = null; }

    const { nodes, edges, usePreset } = filteredElements();

    cy = cytoscape({
      container: $cy,
      textureOnViewport: false,
      wheelSensitivity: 0.2,
      pixelRatio: window.devicePixelRatio || 1,
      elements: { nodes, edges },
      layout: usePreset
        ? { name: 'preset', fit: false, padding: 0 }     // we already rescaled to canvas
        : { name: 'cose', fit: true, padding: 30, animate: false },
      style: [
        {
          selector: 'node',
          style: {
            'background-color': '#5b8def',
            'width':  'mapData(deg, 0, 16, 10, 32)',
            'height': 'mapData(deg, 0, 16, 10, 32)',
            'label': 'data(label)',
            'font-size': 9,
            'text-wrap': 'wrap',
            'text-max-width': 140,
            'color': '#111'
          }
        },
        { selector: 'edge', style: { 'line-color': '#aab', 'width': 1, 'opacity': 0.7 } },
        {
          selector: 'edge[type = "temporal_next"]',
          style: {
            'line-color': '#e83e8c',
            'width': 2,
            'opacity': 0.9,
            'target-arrow-shape': 'triangle',
            'target-arrow-color': '#e83e8c',
            'curve-style': 'bezier'
          }
        },
        { selector: ':selected', style: { 'border-color': '#f59e0b', 'border-width': 2 } }
      ]
    });

    // Label visibility based on zoom
    const applyLabelVisibility = () => {
      const show = cy.zoom() >= 1.2;
      cy.batch(() => cy.nodes().forEach(n => n.style('label', show ? n.data('label') : '')));
    };
    applyLabelVisibility();
    cy.on('zoom', applyLabelVisibility);

    cy.on('tap', 'node', evt => {
      const d = evt.target.data();
      $selected.textContent = JSON.stringify(
        { id: d.id, label: d.label, type: d.type, deg: d.deg },
        null, 2
      );
    });
  }

  async function loadAll() {
    try {
      const manifest = await fetchJSON(`/nexus/run/${encodeURIComponent(RUN_ID)}/manifest`);
      $manifest.textContent = JSON.stringify(manifest, null, 2);
    } catch (e) {
      $manifest.textContent = 'Manifest load error: ' + (e?.message || e);
    }

    try {
      rawGraph = await fetchJSON(`/nexus/run/${encodeURIComponent(RUN_ID)}/graph.json`);
    } catch {
      rawGraph = { nodes: [], edges: [] };
    }

    initCy();
  }

  $btnReload?.addEventListener('click', loadAll);
  $chkKnn?.addEventListener('change', initCy);
  $chkTemporal?.addEventListener('change', initCy);

  loadAll();
});
</script>

{% endblock %}
