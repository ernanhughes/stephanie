# stephanie/data/plan_trace.py
import json
import os
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Union

from stephanie.scoring.score_bundle import ScoreBundle


@dataclass
class ExecutionStep:
    """
    Represents a single step in the execution of a reasoning plan.
    This can be generated by an executor like EpistemicPlanExecutorAgent.
    """
    step_id: Union[str, int]  # Unique identifier for the step (e.g., index, name)
    description: str  # A textual description of what this step does
    output_text: str  # The textual output or result of this step

    # The scores assigned to this step's output by various scorers (SICQL, EBT, etc.)
    # against the original goal. 
    scores: Optional[ScoreBundle] 

    plan_trace_id: Optional[int] = None  # Foreign key to the PlanTrace this step belongs to
    step_order: Optional[int] = None  # Foreign key to the PlanTrace this step belongs to
    # Optional: Embedding of the output_text. Can be computed on demand if not stored.
    
    # Optional: Any other metadata specific to this step
    extra_data: Optional[Dict[str, Any]] = field(default_factory=dict) 

    def to_dict(self) -> Dict[str, Any]:
        return {
            "step_id": self.step_id,
            "description": self.description,
            "output_text": self.output_text,
            "scores": self.scores.to_dict(),
            "plan_trace_id": self.plan_trace_id,
            "step_order": self.step_order,
            "extra_data": self.extra_data,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ExecutionStep":
        from stephanie.scoring.score_bundle import \
            ScoreBundle  # Local import to avoid circular dependencies

        return cls(
            step_id=data.get("step_id"),
            description=data.get("description", ""),
            output_text=data.get("output_text", ""),
            scores=ScoreBundle.from_dict(data.get("scores", {})),
            plan_trace_id=data.get("plan_trace_id"),
            step_order=data.get("step_order"),
            extra_data=data.get("extra_data", {}),
        )


@dataclass
class PlanTrace:
    """
    Represents the complete execution trace of a reasoning plan.
    This is the primary input for the EpistemicTraceEncoder and subsequently 
    the Epistemic Plan HRM model.
    """
    # --- Core Identifiers ---
    trace_id: str # Unique identifier for this specific trace/execution
    
    # --- Initial Context ---
    goal_text: str # The original goal or query
    goal_id: int
    input_data: Dict[str, Any] # Any initial data or variables provided to the plan
    
    # --- Plan Definition (Optional but useful for context) ---
    # This could be a representation of the DSPy program or pipeline used.
    # A simple string signature or a more structured representation.
    plan_signature: str 

    # --- Execution Details ---
    execution_steps: List[ExecutionStep] # The sequence of steps executed
    
    # --- Final Outcome ---
    final_output_text: str # The final output produced by the plan
    # The scores assigned to the final output by various scorers.
    final_scores: Optional[ScoreBundle] = None

    # --- Target for Epistemic Plan HRM Training ---
    # This is the label the HRM model will try to predict.
    # It represents the "epistemic quality" of this reasoning process.
    target_epistemic_quality: Optional[float] = None 
    # Source of the target quality score (e.g., "llm_judgment", "proxy_metric_avg_sicql_q")
    target_epistemic_quality_source: Optional[str] = None 

    # --- Metadata ---
    created_at: str = "" # ISO format timestamp
    # Any other execution metadata (e.g., time taken, DSPy optimizer version)
    extra_data: Optional[Dict[str, Any]] = field(default_factory=dict) 

    def to_dict(self) -> dict:
        return {
            "trace_id": self.trace_id,
            "goal_text": self.goal_text,
            "goal_id": self.goal_id,
            "input_data": self.input_data,
            "plan_signature": self.plan_signature,
            "execution_steps": [step.to_dict() for step in self.execution_steps],
            "final_output_text": self.final_output_text,
            "final_scores": self.final_scores.to_dict(),
            "target_epistemic_quality": self.target_epistemic_quality,
            "target_epistemic_quality_source": self.target_epistemic_quality_source,
            "created_at": self.created_at,
            "extra_data": self.extra_data,
        }

    def get_target_quality(self) -> float:
        if self.has_target_quality():
            return float(self.target_epistemic_quality)
        raise ValueError(f"Trace {self.trace_id} is missing 'target_epistemic_quality'")

    def has_target_quality(self) -> float:
        return self.target_epistemic_quality is not None

    # --- Utility Methods ---
    def get_all_text_outputs(self) -> List[str]:
        """Get a list of all text outputs, including intermediate steps and final output."""
        texts = [step.output_text for step in self.execution_steps]
        texts.append(self.final_output_text)
        return texts

    def get_all_score_bundles(self) -> List[ScoreBundle]:
        """Get a list of all ScoreBundles, including intermediate steps and final output."""
        bundles = [step.scores for step in self.execution_steps]
        bundles.append(self.final_scores)
        return bundles

    def to_markdown(self) -> str:
        lines = [f"## Plan Trace: {self.trace_id}", f"**Goal:** {self.goal_text}\n"]
        for step in self.execution_steps:
            step_id_str = str(step.step_id) if step.step_id is not None else "N/A"
            lines.append(f"### Step {step_id_str}: {step.description}")
            lines.append(f"Output: `{step.output_text}`")
            lines.append(step.scores.to_report(f"Step {step_id_str}: Scores"))
        lines.append(f"\n**Final Output:** `{self.final_output_text}`")
        lines.append("Final Scores:")
        lines.append(self.final_scores.to_report("Trace Final Scores") if self.final_scores else "No final scores available.")
        return "\n".join(lines)

    def save_as_markdown(self, reports_dir: str = "reports") -> str:
        os.makedirs(reports_dir, exist_ok=True)
        markdown_text = self.to_markdown()
        safe_trace_id = "".join(c for c in self.trace_id if c.isalnum() or c in (' ', '-', '_')).rstrip()
        filename = f"{safe_trace_id}.md"
        filepath = os.path.join(reports_dir, filename)
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(markdown_text)
        return filepath

    def save_as_json(self, dir_path: str = "reports/json") -> str:
        os.makedirs(dir_path, exist_ok=True)
        filename = f"{self.trace_id}.json"
        path = os.path.join(dir_path, filename)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(self.to_dict(), f, indent=2)

        print(f"PlanTraceSavedAsJSON path: {path}")

        return path

    @classmethod
    def from_dict(cls, data: dict) -> "PlanTrace":
        from stephanie.scoring.score_bundle import ScoreBundle

        execution_steps = [
            ExecutionStep(
                step_id=step["step_id"],
                description=step["description"],
                output_text=step["output_text"],
                scores=ScoreBundle.from_dict(step["scores"]),
                plan_trace_id=step.get("plan_trace_id"),
                step_order=step.get("step_order"),
                extra_data=step.get("extra_data", {}),
            )
            for step in data["execution_steps"]
        ]

        return cls(
            trace_id=data["trace_id"],
            goal_text=data["goal_text"],
            goal_id=data["goal_id"],
            input_data=data["input_data"],
            plan_signature=data["plan_signature"],
            execution_steps=execution_steps,
            final_output_text=data["final_output_text"],
            final_scores=ScoreBundle.from_dict(data["final_scores"]),
            target_epistemic_quality=data.get("target_epistemic_quality"),
            target_epistemic_quality_source=data.get("target_epistemic_quality_source"),
            created_at=data.get("created_at", ""),
            extra_data=data.get("extra_data", {}),
        )
